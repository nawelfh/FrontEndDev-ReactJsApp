import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/esm/extends";
var _excluded = ["type", "design", "color", "link", "href"],
    _excluded2 = ["type", "design", "color", "alignment", "link", "href"];
import { cloneElement } from 'react';
/**
 * Base class for the component
 */

export var CLASS = 'sui-AtomButton';
/**
 * {Deprecated} Types of buttons
 */

export var TYPES = ['primary', 'accent', 'secondary', 'tertiary'];
/**
 * Different designs for the button
 */

export var DESIGNS = {
  SOLID: 'solid',
  OUTLINE: 'outline',
  FLAT: 'flat',
  LINK: 'link'
};
export var ALIGNMENT = {
  CENTER: 'center',
  LEFT: 'left',
  RIGHT: 'right'
};
/**
 * Available colors for the button
 */

export var COLORS = ['primary', 'accent', 'neutral', 'success', 'alert', 'error', 'social-facebook', 'social-twitter', 'social-google', 'social-youtube', 'social-whatsapp', 'social-instagram'];
/**
 * Positions to be used when the button is used on group
 */

export var GROUP_POSITIONS = {
  FIRST: 'first',
  MIDDLE: 'middle',
  LAST: 'last'
};
/**
 * Shapes for the button
 */

export var SHAPES = {
  SQUARED: 'squared',
  ROUNDED: 'rounded',
  CIRCULAR: 'circular'
};
/**
 * Sizes for the button
 */

export var SIZES = {
  SMALL: 'small',
  LARGE: 'large'
};
/**
 * All the available modifiers for the button
 */

export var MODIFIERS = ['disabled', 'fullWidth', 'focused', 'negative', 'link'];
/**
 * Icon available positions
 */

export var ICON_POSITIONS = {
  LEFT: 'left',
  RIGHT: 'right',
  CENTER: 'center'
};
/**
 * Props for the button in order to filter the rest of attributes
 */

export var OWN_PROPS = [].concat(TYPES, SIZES, ['alignment', 'children', 'className', 'color', 'design', 'isFitted', 'focused', 'fullWidth', 'groupPosition', 'isLoading', 'leftIcon', 'loadingText', 'negative', 'rightIcon', 'type']);
/**
 * Display Name for Atom Icon component
 */

export var ATOM_ICON_DISPLAY_NAME = 'AtomIcon';
/**
 * Map of sizes of the button with the AtomIcon usage
 * The key is the size of the button
 * The value is the size of the icon
 */

export var ATOM_ICON_SIZES_MAPPER = {
  "default": 'small',
  small: 'small',
  large: 'medium'
};
export var TYPES_CONVERSION = {
  primary: {
    design: DESIGNS.SOLID,
    color: 'primary'
  },
  accent: {
    design: DESIGNS.SOLID,
    color: 'accent'
  },
  secondary: {
    design: DESIGNS.OUTLINE,
    color: 'primary'
  },
  tertiary: {
    design: DESIGNS.FLAT,
    color: 'primary'
  }
};
export var createClasses = function createClasses(array, sufix) {
  if (sufix === void 0) {
    sufix = '';
  }

  return array.reduce(function (res, key) {
    var _extends2;

    return _extends({}, res, (_extends2 = {}, _extends2[key] = CLASS + "--" + key + sufix, _extends2));
  }, {});
};
export var CLASSES = createClasses([].concat(COLORS, Object.values(DESIGNS), Object.values(ALIGNMENT), MODIFIERS, Object.values(SIZES), ['empty']));
/**
 * Get props cleaning out AtomButton own props
 * @param  {Object} props
 * @return {Object}
 */

export var cleanProps = function cleanProps(props) {
  var newProps = _extends({}, props);

  OWN_PROPS.forEach(function (key) {
    return delete newProps[key];
  });
  return newProps;
};
/**
 * Get modifiers to apply according to props
 * @param  {Object} props
 * @return {Array<String>}
 */

export var getModifiers = function getModifiers(props) {
  return Object.keys(props).filter(function (name) {
    return props[name] && MODIFIERS.includes(name);
  });
};
export function deprecated(validator, callback) {
  if (callback === void 0) {
    callback = function callback(props, propName, componentName) {
      var deprecatedMessage = "The prop " + '\x1b[32m' + propName + "\x1B[39m" + " is DEPRECATED on " + '\x1b[32m' + componentName + "\x1B[39m" + ".";
      console.warn(deprecatedMessage); // eslint-disable-line
    };
  }

  return function deprecated(props, propName, componentName) {
    for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest[_key - 3] = arguments[_key];
    }

    if (props[propName] != null && process.env.NODE_ENV === 'development') {
      callback.apply(void 0, [props, propName, componentName].concat(rest));
    }

    return validator.apply(void 0, [props, propName, componentName].concat(rest));
  };
}
export var typeConversion = function typeConversion(_ref) {
  var type = _ref.type,
      design = _ref.design,
      color = _ref.color,
      link = _ref.link,
      href = _ref.href,
      other = _objectWithoutPropertiesLoose(_ref, _excluded);

  var result = _extends({
    design: design,
    color: color,
    link: link,
    href: href
  }, other);

  switch (type) {
    case 'primary':
      result.color = color || 'primary';
      result.design = design || (link || href ? DESIGNS.LINK : DESIGNS.SOLID);
      break;

    case 'accent':
      result.color = color || 'accent';
      result.design = design || (link || href ? DESIGNS.LINK : DESIGNS.SOLID);
      break;

    case 'secondary':
      result.color = color || 'primary';
      result.design = design || (link || href ? DESIGNS.LINK : DESIGNS.OUTLINE);
      break;

    case 'tertiary':
      result.color = color || 'primary';
      result.design = design || (link || href ? DESIGNS.LINK : DESIGNS.FLAT);
      break;

    default:
      result.type = type;
      result.color = color || 'primary';
      break;
  }

  return result;
};
export var getPropsWithDefaultValues = function getPropsWithDefaultValues(_ref2) {
  var type = _ref2.type,
      design = _ref2.design,
      color = _ref2.color,
      alignment = _ref2.alignment,
      link = _ref2.link,
      href = _ref2.href,
      other = _objectWithoutPropertiesLoose(_ref2, _excluded2);

  return _extends({}, other, {
    link: link,
    type: type,
    design: design || (link || href ? DESIGNS.LINK : DESIGNS.SOLID),
    color: color || 'colors',
    alignment: alignment || ALIGNMENT.CENTER
  });
};
/**
 * Detect if element is an AtomIcon to force correct size
 * @param {React.ReactElement} icon
 */

export var isAtomIcon = function isAtomIcon(icon) {
  var _icon$type;

  return (icon == null ? void 0 : (_icon$type = icon.type) == null ? void 0 : _icon$type.displayName) === ATOM_ICON_DISPLAY_NAME;
};
/**
 * Prepare the AtomIcon element to use the correct size
 * @param {React.ReactElement} atomIconElement
 * @param {object} options
 * @param {string} options.size Size of the button to grab the correct icon size
 */

export var prepareAtomIcon = function prepareAtomIcon(atomIconElement, _ref3) {
  var size = _ref3.size;
  var atomIconSize = ATOM_ICON_SIZES_MAPPER[size];
  return /*#__PURE__*/cloneElement(atomIconElement, {
    color: undefined,
    size: atomIconSize
  });
};